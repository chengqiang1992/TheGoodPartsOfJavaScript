<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="keywords" content="JavaScript语言精粹  第四章 函数">
    <meta name="description" content="JavaScript语言精粹  第四章 函数 读书笔记">
    <meta name="author" content="">
    <link rel="icon" href="http://getbootstrap.com/favicon.ico">

    <title>第四章 函数</title>

    <link rel="stylesheet" type="text/css" href="../assets/global/plugins/bootstrap-3.3.6-dist/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../assets/global/css/global.css">
</head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="javascript:void(0);">第四章 函数</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="javascript:void(0);">Home</a></li>
            <li><a href="javascript:void(0);">About</a></li>
            <li><a href="javascript:void(0);">Contact</a></li>
          </ul>
          <form class="navbar-form navbar-right">
            <div class="form-group">
              <input type="text" placeholder="Email" class="form-control">
            </div>
            <div class="form-group">
              <input type="password" placeholder="Password" class="form-control">
            </div>
            <button type="submit" class="btn btn-success">Sign in</button>
          </form>
        </div><!--/.navbar-collapse -->
      </div>
    </nav>

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
      <div class="container">
        <h2>第四章  函数</h2>
        <h4>所有的过失在未犯以前，都已定下应处的惩罚</h4>
        <h4>——威廉·莎士比亚，《一报还一报》（Measure for Measure）</h4>

        <p>JavaScript设计得最出色的就是它的函数的实现。它几乎接近于完美。但是，想必你也能预料到，Javascript的函数也存在瑕疵。</p>
        <p>函数包含一组语句，它们是JavaScript的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于指定对象的行为。一般来说，所谓编程，就是将一组需求分解成一组函数与数据结构的技能。</p>
        <p><a class="btn btn-primary btn-lg" href="http://getbootstrap.com/examples/jumbotron/#" role="button">Learn more »</a></p>
      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>函数对象 Function Objects</h2>
          <p>JavaScript中的函数就是对象。对象是“名/值”对的集合并拥有一个连接到原型对象的隐藏连接。对象字面量产生的对象连接到 Object.prototype。函数对象连接到 Function.prototype(该原型对象本身连接到Object.prototype)。每个函数在创建时会附加两个颖仓属性：函数的上下文和实现函数行为的代码。</p>
          <p>每个函数对象在创建时也随配有一个 Prototype 属性。它的值是一个拥有 constructor 属性并且值即位该函数的对象。这和隐藏连接到 Function.prototype 完全不同。这个令人费解的构造过程的意义将会在下个章节中揭示。</p>
          <p>因为函数是对象，所以他们可以把像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当作参数传递给其他函数，函数也可以再返回函数。而且，因为函数是对象，所以函数可以拥有方法。</p>
          <p><strong>函数的与众不同之处在于他们可以被调用</strong></p>
          <p><a class="btn btn-default" href="http://getbootstrap.com/examples/jumbotron/#" role="button">View details »</a></p>
        </div>
      </div>

      <div class="row">
         <div class="col-md-12">
           <h2>函数字面量 Function Literal</h2>
           <p>函数对象通过函数字面量来创建</p>
           <pre>
             <code>
 //创建一个名为add的变量，并用来把两个数字相加的函数赋值给它。
 var add = function(a,b){
   return a + b;
 };
             </code>
           </pre>
           <p>函数字面量包括4个部分。第一部分是保留字function。</p>
           <p>第二部分是函数名，它可以被省略。函数可以用他的名字来递归调用自己。此名字也能被调试器和开发工具来识别函数。如果没有给函数命名，比如上面这个例子，它被称为匿名函数（anonymous）。</p>
           <p>函数的第三个部分是包围在圆括号中的一组参数。多个参数用逗号分隔。这些参数的名称将被定义为函数中的变量。它们不像普通的变量那样被初始化为undefined，而是在该函数被调用时初始化为实际提供的参数的值。</p>
           <p>第四个部分是包围在花括号中的一组语句。这些语句是函数的主体，他们在函数被调用时执行。</p>
           <p>函数字面量可以出现在任何允许表达式出现的地方。函数也可以被定义在其他函数中。一个内部函数除了可以访问自己的参数和变量，同时他也能自由访问把他嵌套在其中的父函数的参数与变量。通过函数字面量创建的函数对象包含一个连接到到外部上下文的连接。这被称为<span style="color: red">闭包（closure）。</span>它是JavaScript强大表现力的来源。</p>
           <p><a class="btn btn-default" href="http://getbootstrap.com/examples/jumbotron/#" role="button">View details »</a></p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>调用 Invocation</h2>
          <p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数：this和arguments。参数this在面向对象编程中非常重要，它的值取决于调用的模式。在JavaScript中一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。这些模式在如何初始化关键参数this上存在差异。</p>
          <p>实际参数与形式参数个数不配，不会出现错误。</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>方法调用模式 The Method Invocation Pattern</h2>
          <p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。如果调用表达式包含一个提取属性的动作（即包含一个.点表达式或[subscript]下标表达式），那么它就是被当作一个方法来调用。</p>
          <p>实际参数与形式参数个数不配，不会出现错误。</p>
          <pre>
            <code>
  //创建myObject对象。他有一个value属性和一个increment方法。
  //increment方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1。
  var myObject = {
    value:0,
    increment:function(inc){
      this.value += typeof inc === 'number' ? inc : 1;
    }
  };

  myObject.increment();
  console.log(myObject.value);

  myObject.increment(2);
  console.log(myObject.value);
            </code>
          </pre>
          <p>方法可以使用this访问自己所属的对象，所以他能从对象中取值或对对象进行修改。this到对象的绑定发生在调用的时候。这是“超级”延迟绑定(very late binding)使得函数可以对this高度复用。通过this可取得他们所属对象的上下文的方法称为公共方法(public method)。</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>函数调用模式  The Function Invocation Pattern</h2>
          <p>当一个函数并非一个对象的属性时，那么它就是被当作一个函数来调用的：</p>
          <pre>
            <code>
  var sum = add(3,4); //sum的值为7
            </code>
          </pre>
          <P>以此模式调用函数时，this被绑定到全局对象。这是语言设计上的一个错误。倘若语言设计正确，那么当内部函数被调用时，thsi应该仍然绑定到外部函数的this变量。这个设计错误的后果就是方法不能利用内部函数来帮助他工作，因为内部函数的this被绑定了错误的值，所以不能共享该方法对对象的访问权。幸运的是，有一个很容易的解决方案：如果该方法定义一个变量并给它赋值this，那么内部函数就可以通过那个变量访问到this。按照约定，我把那个变量命名为that。</P>
          <pre>
            <code>
  //给myObject增加一个double方法。
  myObject.double = function(){
    var that = this;  //解决办法

    var helper = function(){
      that.value = add(that.value,that.value);
    };

    helper(); //以函数的形式调用helper。
  };

  //以方法的形式调用double。
  myObject.double();
  console.log(myObject.value);
            </code>
          </pre>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>构造器调用模式 The Constructor Invocation Pattern</h2>
          <p>JavaScript是一门基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。该语言是无类型的。</p>
          <p>这偏离了当今编程语言的主流风格。当今大多数语言都是基于类的语言。尽管原型继承极富表现力，但他并未广泛理解。Javascript本身对它的原型的本质也缺乏信心，所以它提供了一套和基于类的语言类似的对象构建语法。有类型化语言编程的程序员们很少有愿意接受原型继承的，并且认为借鉴类型语言的语法模糊了这门语言真实的原型本质。真是两边都不讨好。</p>
          <p>如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该该函数的 prototype 成员的新对象，同时this会绑定到那个新对象上。</p>
          <p>new前缀也会改变return语句的行为。我们将会在后面看到更多的相关内容。</p>
          <pre>
            <code>
  //创建一个名为Quo的构造函数，它构造一个带有status属性的对象。
  var Quo = function(string){
    this.status = string;
  };
  //给Quo的所有实例提供一个名为get_status的公共方法。
  Quo.prototype.get_status = function(){
    return this.status;
  };
  //构造一个Quo实例。
  var myQuo = new Quo("confused");
  console.log(myQuo.get_status());
            </code>
          </pre>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>Apply 调用模式  The Apply Invocation Pattern</h2>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>参数  Arguments</h2>
          <p>当函数被调用时，会得到一个“免费”配送的参数，那就是 arguments 数组。函数可以用过此参数访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。这使得编写一个无须指定参数个数的函数成为可能：</p>
          <pre>
            <code>
  //构造一个将大量的值增加的函数。
  //注意该函数内部定义的变量sum不会与函数外部定义的sum产生冲突。
  //该函数只会看到内部的那个变量
  var sum = function(){
    var i,sum = 0;
    for(i = 0;i < arguments.length;i += 1){
      sum += arguments[i];
    }
    return sum;
  };
  console.log(sum(4,8,15,16,23,42));
            </code>
          </pre>
          <p>因为语言的一个设计错误，arguments 并不是一个真正的数组。它只是一个“类似数组(array-like)”的对象。arguments拥有一个length属性，但它没有任何数组的方法。</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>返回  Return</h2>
          <p>当一个函数被调用时，它从一个语句开始执行，并在遇到关闭函数体的}时结束。然后函数包控制权交还给调用该函数的程序。</p>
          <p>return语句可用来使函数提前返回。当return被执行时，函数立即返回而不再执行余下的语句。</p>
          <p>一个函数总会返回一个值。如果没有指定返回值，则返回undefined。</p>
          <p>如果函数调用时在前面加上了new前缀，且返回的不是一个对象，则返回this。</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>异常  Exceptions</h2>
          <p>JavaScript提供了一套完整异常处理机制。异常时干扰程序的正常流程的不寻常的事故。当发现这样的事故时，你的程序应该抛出一个异常：</p>
          <pre>
            <code>
  var add  =function(a,b){
    if (typeof a !== 'number' || typeof b !== 'number' ) {
      throw{
        name:'TypeError',
        message:'add needs numbers'
      };
    }
    return a + b;
  }
            </code>
          </pre>
          <p>throw语句中断函数的执行。它应该抛出一个exception对象，该对象包含一个用来识别异常类型的name属性和一个描述性的message属性。你也可以添加其他的属性。</p>
          <p>该exception对象将被传递到一个try语句和catch从句：</p>
          <pre>
            <code>
  //构造一个try_it函数，以不正确的方式调用之前的add函数。
  var try_it = function(){
    try{
      add('seven');
    }catch(e){
      console.log(e.name + ': ' + e.message);
    }
  }
  try_it();
            </code>
          </pre>
          <p>如果在try代码块内抛出了一个异常，控制权就会跳转到它的catch从句。</p>
          <p>一个try语句只会有一个捕获所有异常的catch代码块。如果你的处理手段取决于异常的类型，那么异常处理器必须检查异常对象的name属性来确定异常类型。</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>递归  Recursion</h2>
          <p>递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，他把一个问题分解成为一组相似的子问题，每一个都用一个寻常解去解决。一般来说，一个递归函数调用自身去解决它的子问题。</p>
          <p>“汉诺塔”是一个著名的益智游戏。详见<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94">汉诺塔</a></p>
          <pre>
            <code>
  // 递归  Recursion
  var hanoi = function(disc,src,aux,dst){
    if(disc > 0){
      hanoi(disc-1,src,dst,aux);
      console.log('Move disc ' + disc + ' from ' + src + ' to ' +dst);
      hanoi(disc-1,aux,src,dst);
    }
  };
  hanoi(3,'Src','Aux','Dst');
            </code>
          </pre>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>模块  Module</h2>
          <p>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数产生模块。我们几乎可以完全摒弃全局变量的使用，从而缓解这个JavaScript的最为糟糕的特性之一所带来的影响。</p>
          <p>举例来说，假定我们想要给String增加一个deentityify方法。它的任务是寻找字符串中的HTML字符体并把它们替换成对应的字符。这就需要在一个对象中保存字符实体的名字和他们对应的字符。但我们该在哪里保存这个对象呢？我们可以把它放到一个全局变量中，但全局变量是魔鬼。我们可以把它定义在该函数的内部，但是那会带来运行时的损耗，因为每次执行该函数的时候该字面量都会被求值一次。理想的方式是把它放入一个闭包中，而且也许还能提供一个增加更多字符实体的扩展方法：</p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>级联</h2>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>柯里化</h2>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h2>记忆  Memoization</h2>
          <p>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被成为记忆。JavaScript的对象和数组要实现这种优化是非常方便的。</p>
          <p>比如说，我们想要一个递归函数来计算 Fibonacci 数列。一个 Fibonacci 数字是之前两个 Fibonacci 数字之和</p>
          <pre>
            <code>
  // 记忆  Memoization
  var fibonacci = function(n){
    return n<2 ? n : fibonacci(n-1) + fibonacci(n-2);
  };
  for(var i=0; i <= 10; i+=1){
    console.log('// ' + i + ': ' + fibonacci(i));
  }
            </code>
          </pre>
          <p>这样是可以工作的，但它做了很多无谓的工作。Fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能刚计算过的值。如果我们让该函数具有<span style="color: red;font-size: 18px">记忆</span>功能，就可以显著减少运算量。</p>
          <p>我们在一个名为memo的数组里保存我们的存储结果，存储结果可以隐藏在闭包中。当函数被调用时，这个函数首先检查结果是否已存在，如果已经存在，就立即返回这个结果。</p>
              <pre>
            <code>
  var fibonacci = function(){
    var memo = [0,1];
    var fib = function(n){
      var result = memo[n];
      if (typeof result !== 'number') {
        result = fib(n-1) + fib(n-2);
        memo[n] = result;
      }
      return result;
    };
    return fib;
  }();
            </code>
          </pre>

        </div>
      </div>
      <hr>



      <footer>
        <div class="page-footer-inner">
            2016 &copy; 610工作室. <a href="http://www.choudiaosi.com" target="_blank">610工作室!</a>
        </div>
      </footer>
    </div> <!-- /container -->

    <!-- Bootstrap core JavaScript-->
    <script type="text/javascript" src="../assets/global/plugins/JQuery/jquery-2.2.3.min.js"></script>
    <script type="text/javascript" src="../assets/global/plugins/bootstrap-3.3.6-dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../assets/pages/scripts/Unit_4.js"></script>
</body>
</html>